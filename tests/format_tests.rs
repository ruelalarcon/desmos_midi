// Tests for validating the exact format of Desmos formula outputs
//
// This file contains tests that verify the exact output format of the Desmos formulas
// generated by the MidiProcessor. These tests ensure that processing MIDI files with
// soundfonts produces the expected Desmos formula strings, which is critical for
// compatibility with the Desmos graphing calculator.
//
// The tests use soundfont files from the tests/samples directory to ensure test stability
// and independence from changes to the default soundfont files.

use desmos_midi::midi;

// Import the test utils
mod test_utils;
use test_utils::{SAMPLES_DIR, SINE_SOUNDFONT, SQUARE_SOUNDFONT};

// Constants for expected outputs
const EXPECTED_C4_CHROMATIC_60BPM: &str = "A=\\left\\{t<1.000:\\left[-9,100,0\\right],t<2.000:\\left[-8,100,0\\right],t<3.000:\\left[-7,100,0\\right],t<4.000:\\left[-6,100,0\\right],t<5.000:\\left[-5,100,0\\right],t<6.000:\\left[-4,100,0\\right],t<7.000:\\left[-3,100,0\\right],t<8.000:\\left[-2,100,0\\right],t<9.000:\\left[-1,100,0\\right],t<10.000:\\left[0,100,0\\right],t<11.000:\\left[1,100,0\\right],t<12.000:\\left[2,100,0\\right],t<13.000:\\left[3,100,0\\right],t<13.1:\\left[\\right]\\right\\}";
const EXPECTED_C4_CHROMATIC_DYNAMICBPM: &str = "A=\\left\\{t<1.000:\\left[-9,100,0\\right],t<2.000:\\left[-8,100,0\\right],t<3.000:\\left[-7,100,0\\right],t<4.000:\\left[-6,100,0\\right],t<4.250:\\left[-5,100,0\\right],t<4.500:\\left[-4,100,0\\right],t<4.750:\\left[-3,100,0\\right],t<5.000:\\left[-2,100,0\\right],t<5.250:\\left[-1,100,0\\right],t<5.500:\\left[0,100,0\\right],t<5.750:\\left[1,100,0\\right],t<6.000:\\left[2,100,0\\right],t<6.250:\\left[3,100,0\\right],t<6.35:\\left[\\right]\\right\\}";
const EXPECTED_C4C5_CHROMATIC_PIANO_SAX_DYNAMICBPM: &str = "A=\\left\\{t<1.000:\\left[-9,100,0,3,100,1\\right],t<2.000:\\left[-8,100,0,2,100,1\\right],t<3.000:\\left[-7,100,0,1,100,1\\right],t<4.000:\\left[-6,100,0,0,100,1\\right],t<4.250:\\left[-5,100,0,-1,100,1\\right],t<4.500:\\left[-4,100,0,-2,100,1\\right],t<4.750:\\left[-3,100,0,-3,100,1\\right],t<5.000:\\left[-4,100,1,-2,100,0\\right],t<5.250:\\left[-5,100,1,-1,100,0\\right],t<5.500:\\left[-6,100,1,0,100,0\\right],t<5.750:\\left[-7,100,1,1,100,0\\right],t<6.000:\\left[-8,100,1,2,100,0\\right],t<6.250:\\left[-9,100,1,3,100,0\\right],t<6.35:\\left[\\right]\\right\\}";
const EXPECTED_440HZ_HARMONICS: &str = "1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0";

// Expected outputs for B and C components
const EXPECTED_B_COMPONENT: &str = "B=\\left[1\\right]";
const EXPECTED_B_COMPONENT_MUTLI_INSTRUMENT: &str =
    "B=\\left[1,0,0,0,0,0,0,0,0,0,1,0,0.33333,0,0.2,0,0.14286,0,0.11111,0\\right]";
const EXPECTED_C_COMPONENT: &str = "C=1";

/// Test that processing a MIDI file with constant BPM produces the expected formula.
///
/// This test verifies:
/// - Processing of a C4 chromatic scale with constant 60 BPM
/// - Use of a single-channel with the sine soundfont
/// - Exact matching of the Desmos formula components (A, B, C)
#[test]
fn test_format_c4_chromatic_60bpm() {
    let midi_path = "tests/samples/c4_chromatic_60bpm.mid";
    let soundfonts = vec![String::from(SINE_SOUNDFONT)];

    // Create a MidiProcessor with the custom samples directory
    let processor = midi::MidiProcessor::with_soundfont_dir(SAMPLES_DIR);
    let result = processor
        .process_with_soundfonts(midi_path, soundfonts)
        .expect("Failed to process MIDI file with soundfonts");

    let formula = result.to_piecewise_function();

    // Check each component matches exactly as shown in CLI output
    assert!(
        formula.contains(EXPECTED_C4_CHROMATIC_60BPM),
        "Formula A component should match expected output"
    );
    assert!(
        formula.contains(EXPECTED_B_COMPONENT),
        "Formula B component should match expected output"
    );
    assert!(
        formula.contains(EXPECTED_C_COMPONENT),
        "Formula C component should match expected output"
    );
}

/// Test that processing a MIDI file with dynamic BPM produces the expected formula.
///
/// This test verifies:
/// - Processing of a C4 chromatic scale with changing tempo
/// - Correct handling of tempo changes in the output formula
/// - Exact matching of the Desmos formula components (A, B, C)
#[test]
fn test_format_c4_chromatic_dynamicbpm() {
    let midi_path = "tests/samples/c4_chromatic_dynamicbpm.mid";
    let soundfonts = vec![String::from(SINE_SOUNDFONT)];

    // Create a MidiProcessor with the custom samples directory
    let processor = midi::MidiProcessor::with_soundfont_dir(SAMPLES_DIR);
    let result = processor
        .process_with_soundfonts(midi_path, soundfonts)
        .expect("Failed to process MIDI file with soundfonts");

    let formula = result.to_piecewise_function();

    // Use the expected constants provided in the requirements
    assert!(
        formula.contains(EXPECTED_C4_CHROMATIC_DYNAMICBPM),
        "Formula A component should match expected output"
    );
    assert!(
        formula.contains(EXPECTED_B_COMPONENT),
        "Formula B component should match expected output"
    );
    assert!(
        formula.contains(EXPECTED_C_COMPONENT),
        "Formula C component should match expected output"
    );
}

/// Test that processing a MIDI file with multiple channels/instruments produces the expected formula.
///
/// This test verifies:
/// - Processing of a MIDI file with two different instruments (piano and sax)
/// - Mapping of different soundfonts to different channels
/// - Format of more complex Desmos formula with multiple instruments
/// - Handling of channel-specific harmonic data
#[test]
fn test_format_c4c5_chromatic_piano_sax_dynamicbpm() {
    let midi_path = "tests/samples/c4c5_chromatic_piano_sax_dynamicbpm.mid";
    let soundfonts = vec![String::from(SINE_SOUNDFONT), String::from(SQUARE_SOUNDFONT)];

    // Create a MidiProcessor with the custom samples directory
    let processor = midi::MidiProcessor::with_soundfont_dir(SAMPLES_DIR);
    let result = processor
        .process_with_soundfonts(midi_path, soundfonts)
        .expect("Failed to process MIDI file with soundfonts");

    let formula = result.to_piecewise_function();

    // Check the A component contains the expected pattern
    assert!(
        formula.contains(EXPECTED_C4C5_CHROMATIC_PIANO_SAX_DYNAMICBPM),
        "Formula should contain the expected notes pattern"
    );

    // Check the B component contains the expected harmonics pattern
    assert!(
        formula.contains(EXPECTED_B_COMPONENT_MUTLI_INSTRUMENT),
        "Formula should contain the expected harmonics"
    );

    // Check the C component
    assert!(
        formula.contains("C=10"),
        "Formula should contain the expected harmonic count"
    );
}

/// Test that the harmonics analysis produces the expected format.
///
/// This test verifies:
/// - The format of harmonic analysis output for a 440Hz sine wave
/// - The expected pattern where only the first harmonic has a significant value
/// - The expected number of harmonics (16)
#[test]
fn test_audio_harmonics_format() {
    // This test verifies that the harmonics output format matches the expected format
    // For a 440Hz sine wave, we expect a series of values with only the first harmonic significant

    // Use the expected harmonics constant
    let expected_harmonics = EXPECTED_440HZ_HARMONICS;

    // Check that it has the expected format (16 comma-separated values)
    let values: Vec<&str> = expected_harmonics.split(',').collect();
    assert_eq!(values.len(), 16, "Should have exactly 16 harmonics");

    // First value should be 1.0
    assert_eq!(values[0], "1", "First harmonic should be 1.0");

    // Rest should be 0.0
    for &value in &values[1..] {
        assert_eq!(value, "0", "Higher harmonics should be 0.0");
    }
}
